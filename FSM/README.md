# 🎮 Finite State Machine (FSM) in Unity

## 📖 설명
FSM(Finite State Machine)은 객체의 상태를 정의하고,  
상태 간 전환 로직을 명확히 분리하여 **유지보수성과 가독성을 높이는 패턴**입니다.

## 🧠 유니티에서의 사용 예
- 캐릭터 상태 (Idle, Run, Attack, Jump)
- 보스 패턴 (Phase1 → Phase2 → Rage)
- UI 단계 (Start → Loading → MainMenu → Game)

---

## 🔁 구현 방식

### 🔸 클래스 기반 FSM (`abstract class State`)
- 상태를 추상 클래스로 정의하고 상속을 통해 구현
- 공통 로직(예: Enter, Exit, Update)을 기본 제공

📄 관련 파일:
- `BaseState.cs`
- `StateMachine.cs`
- `State_Idle.cs`, `State_Run.cs`, `State_Attack.cs`

---

### 🔸 인터페이스 기반 FSM (`IState`)
- 상태를 인터페이스로 정의하여 유연한 구조
- 경량 FSM, 구성 요소가 가볍고 독립적임

📄 관련 파일:
- `IState.cs`
- `StateMachine.cs` (같이 사용)
- 동일한 상태 클래스 사용 가능

---

## 📊 비교 요약

| 방식               | 장점                                      | 단점                                | 추천 상황                     |
|--------------------|-------------------------------------------|-------------------------------------|-------------------------------|
| 클래스 기반        | ✅ 코드 재사용 쉬움<br>✅ 추상화 명확       | ❌ 유연성 낮음<br>❌ 단일 상속 제한 | 복잡한 FSM / 공통 로직 많을 때 |
| 인터페이스 기반    | ✅ 유연하고 독립적<br>✅ 다중 상태 구현 가능 | ❌ 공통 코드 중복 가능               | 간단한 FSM / 조합 유연성 필요할 때 |

---

## 👍 장점

- 상태 변경과 로직이 명확하게 분리되어 가독성/유지보수성 향상
- 상태가 객체로 나뉘어 있어 디버깅/테스트 용이
- 상태 전환 조건이 구조적으로 관리됨 (if문 난무 방지)

---

## ❌ 단점

- 오버엔지니어링 주의: 간단한 상황에서는 과한 구조일 수 있음
- 많은 상태일 경우 클래스 수 증가 → 관리 복잡
- 인터페이스 기반은 공통 코드 재사용이 어렵고 복잡해질 수 있음


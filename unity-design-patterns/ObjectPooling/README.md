# 🧺 Object Pooling in Unity

## 📖 개념

Object Pooling은 자주 생성/파괴되는 오브젝트(예: 총알, 이펙트 등)를  
미리 만들어두고 재사용하는 방식의 성능 최적화 패턴입니다.

- 메모리 할당/해제 비용을 줄이고
- `Instantiate()` / `Destroy()` 호출을 최소화해
- **GC(가비지 컬렉션)**과 **프레임 드롭**을 방지합니다.

---

## 🧠 유니티에서의 사용 예

- 총알 발사 시스템 (Bullet Pool)
- 이펙트 재생 (Explosion Pool)
- 적 생성/소멸 (Enemy Pool)
- UI 아이템 동적 리스트 (Slot Pool)

---

## 🛠 구현 방식

### 🔸 1. 직접 구현한 커스텀 풀

직접 `Queue`나 `Stack`을 이용해 오브젝트를 생성/재사용하는 방식

📄 예제: `CustomObjectPool.cs`

**장점**  
- 완전한 제어 가능  
- 키 기반 풀 등 구조 커스터마이징 쉬움  

**단점**  
- 코드 길고, 실수하기 쉬움  
- GC 관리 직접 해줘야 함

---

### 🔸 2. Unity 제공 `ObjectPool<T>`

`UnityEngine.Pool` 네임스페이스에서 제공하는 공식 풀링 클래스

📄 예제: `UnityObjectPoolExample.cs`

**장점**  
- 안정적이고 최적화됨  
- 콜백(`OnGet`, `OnRelease`, `OnDestroy`) 등 라이프사이클 지원  
- GC 부담 적음

**단점**  
- 고급 제어(예: 키 기반 풀)는 직접 구현 필요  
- Unity 2021.1 이상 필요

---

### 🔸 3. LinkedPool<T>

유니티의 `LinkedPool<T>`는 대량의 객체를 자주 풀링해야 할 때  
**GC 압력**을 줄이기 위해 설계된 구조입니다.

📄 예제: `LinkedPoolExample.cs`

**추천 상황**
- 수백 개 이상의 객체를 계속 꺼내고 넣는 경우 (총알, 파티클 등)

---

## 📊 구현 비교

| 항목                 | Custom Pool     | ObjectPool<T>      | LinkedPool<T>       |
|----------------------|------------------|----------------------|----------------------|
| 직접 제어 가능        | ✅               | ⚠️ 제한적             | ⚠️ 제한적             |
| GC 성능 최적화        | ❌ 수동 관리       | ✅ 자동 관리           | ✅ 매우 우수           |
| 키 기반 제어          | ✅               | ❌ 미지원             | ❌ 미지원             |
| 개발 난이도           | ❗높음             | ✅ 간단                | ✅ 간단                |
| 유니티 버전 필요       | 없음              | 2021.1+              | 2022.1+ (권장)        |

---

## 👍 장점

- 메모리 재사용 → 성능 향상 (특히 모바일/VR 환경)
- 프레임 드롭 방지 (Instantiate/Destroy 호출 최소화)
- 오브젝트 수 예측 가능 → GC 쓰레기 줄임

---

## ❌ 단점

- 풀 크기를 잘못 잡으면 메모리 낭비 또는 부족
- 비정상 사용 시(이중 반환 등) 버그 유발 가능
- 복잡한 경우 직접 관리 필요

---

## ✅ 요약 한 줄

> 자주 쓰이는 오브젝트는 **미리 만들어서 재사용하자!**  
> 직접 풀링하거나, `ObjectPool<T>`를 사용하자!

